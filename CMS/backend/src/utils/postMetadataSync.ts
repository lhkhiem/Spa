import sequelize from '../config/database';
import Asset from '../models/Asset';
import Tag from '../models/Tag';
import { stripHtmlAndDecode } from './metadataHelpers';

const DEFAULTS = {
  seo: {
    home: { title: 'Banyco', description: '', ogImage: '', slug: '/' },
    pages: [],
  },
};

/**
 * Normalize slug to match frontend normalization
 * This ensures the path matches what the frontend generates when querying metadata
 */
function normalizeSlug(slug: string): string {
  if (!slug) return '';
  
  // Decode URL-encoded characters first
  try {
    slug = decodeURIComponent(slug);
  } catch (e) {
    // If decode fails, use original slug
  }
  
  return slug
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9-]/g, '-') // Replace special chars with dash
    .replace(/-+/g, '-') // Replace multiple dashes with single dash
    .replace(/^-+|-+$/g, ''); // Remove leading/trailing dashes
}

/**
 * Sync post metadata to CMS Settings
 * This function is called automatically when a post is created or updated.
 * It will only update if the metadata is auto-generated (not custom).
 */
export async function syncPostMetadataToCMS(post: any) {
  try {
    // Normalize slug to match frontend normalization
    const normalizedSlug = normalizeSlug(post.slug || '');
    const path = `/posts/${normalizedSlug}`;

    // 1. Fetch current SEO settings
    const [seoRow] = await sequelize.query(
      'SELECT value FROM settings WHERE namespace = :ns',
      {
        type: 'SELECT' as any,
        replacements: { ns: 'seo' },
      }
    ) as any[];

    const seoSettings = seoRow?.[0]?.value ?? DEFAULTS.seo;
    const existingPages = seoSettings.pages || [];

    // 2. Check if custom metadata exists (not auto-generated)
    const existingIndex = existingPages.findIndex((p: any) => p.path === path);
    const existing = existingPages[existingIndex];

    // 3. If custom metadata exists (not auto-generated), don't override
    if (existing && !existing.autoGenerated) {
      console.log(`[syncPostMetadata] Skipping ${path} - has custom metadata`);
      return; // Keep custom metadata, don't override
    }

    // 4. Load cover image
    let coverUrl = '';
    if (post.cover_asset_id) {
      const coverAsset = await Asset.findByPk(post.cover_asset_id);
      if (coverAsset) {
        coverUrl = (coverAsset as any).cdn_url || (coverAsset as any).url || '';
      }
    }

    // 5. Load tags
    let tagNames: string[] = [];
    try {
      const tags = await (post as any).getTags?.() || [];
      tagNames = tags.map((t: any) => t.name || '').filter(Boolean);
    } catch (err) {
      console.warn('[syncPostMetadata] Could not load tags:', err);
    }

    // 6. Create/update auto-generated metadata
    // Clean description: strip HTML and decode entities
    let description = post.excerpt || post.title || '';
    description = stripHtmlAndDecode(description);
    if (description.length > 160) {
      description = description.substring(0, 157) + '...';
    }
    
    const metadata = {
      path,
      title: post.title || '',
      description: description,
      ogImage: coverUrl,
      keywords: tagNames,
      enabled: true,
      autoGenerated: true, // Flag to identify auto-generated metadata
    };

    // 7. Update or add to pages array
    if (existingIndex >= 0) {
      existingPages[existingIndex] = metadata; // Update existing
    } else {
      existingPages.push(metadata); // Add new
    }

    // 8. Save to settings
    await sequelize.query(
      `INSERT INTO settings (namespace, value, updated_at)
       VALUES (:ns, :val::jsonb, NOW())
       ON CONFLICT (namespace) DO UPDATE SET value = EXCLUDED.value, updated_at = NOW()`,
      {
        type: 'INSERT' as any,
        replacements: {
          ns: 'seo',
          val: JSON.stringify({
            ...seoSettings,
            pages: existingPages,
          }),
        },
      }
    );

    console.log(`[syncPostMetadata] Synced metadata for ${path}`);
  } catch (error) {
    console.error('[syncPostMetadata] Error:', error);
    // Don't throw error to avoid breaking post creation/update
  }
}

