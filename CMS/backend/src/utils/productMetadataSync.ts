import sequelize from '../config/database';
import Asset from '../models/Asset';
import { stripHtmlAndDecode } from './metadataHelpers';

const DEFAULTS = {
  seo: {
    home: { title: 'Banyco', description: '', ogImage: '', slug: '/' },
    pages: [],
  },
};

/**
 * Normalize slug to match frontend normalization
 * This ensures the path matches what the frontend generates when querying metadata
 */
function normalizeSlug(slug: string): string {
  if (!slug) return '';
  
  // Decode URL-encoded characters first
  try {
    slug = decodeURIComponent(slug);
  } catch (e) {
    // If decode fails, use original slug
  }
  
  return slug
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9-]/g, '-') // Replace special chars with dash
    .replace(/-+/g, '-') // Replace multiple dashes with single dash
    .replace(/^-+|-+$/g, ''); // Remove leading/trailing dashes
}

/**
 * Sync product metadata to CMS Settings
 * This function is called automatically when a product is created or updated.
 * It will only update if the metadata is auto-generated (not custom).
 */
export async function syncProductMetadataToCMS(product: any) {
  try {
    // Normalize slug to match frontend normalization
    const normalizedSlug = normalizeSlug(product.slug || '');
    const path = `/products/${normalizedSlug}`;

    // 1. Fetch current SEO settings
    const [seoRow] = await sequelize.query(
      'SELECT value FROM settings WHERE namespace = :ns',
      {
        type: 'SELECT' as any,
        replacements: { ns: 'seo' },
      }
    ) as any[];

    const seoSettings = seoRow?.[0]?.value ?? DEFAULTS.seo;
    const existingPages = seoSettings.pages || [];

    // 2. Preserve all static pages and non-product pages
    // Static pages are: pages that are NOT auto-generated product pages
    const staticPages = existingPages.filter((p: any) => {
      // Keep all pages that are NOT auto-generated product pages
      // This includes: static pages, custom product pages, post pages, etc.
      return !(p.autoGenerated === true && p.path?.startsWith('/products/'));
    });

    // 3. Get existing auto-generated product pages (to update/merge)
    const existingProductPages = existingPages.filter((p: any) => 
      p.autoGenerated === true && p.path?.startsWith('/products/')
    );

    // 4. Check if custom metadata exists (not auto-generated) for this specific product
    const existingIndex = existingPages.findIndex((p: any) => p.path === path);
    const existing = existingPages[existingIndex];

    // 5. If custom metadata exists (not auto-generated), don't override
    if (existing && !existing.autoGenerated) {
      console.log(`[syncProductMetadata] Skipping ${path} - has custom metadata`);
      return; // Keep custom metadata, don't override
    }

    // 4. Load thumbnail image
    let thumbnailUrl = '';
    if (product.thumbnail_id) {
      const thumbnailAsset = await Asset.findByPk(product.thumbnail_id);
      if (thumbnailAsset) {
        thumbnailUrl = (thumbnailAsset as any).cdn_url || (thumbnailAsset as any).url || '';
      }
    }

    // 5. Get description from product
    let description = product.description || '';
    if (!description && product.content) {
      // Try to extract description from content
      if (typeof product.content === 'object' && product.content.meta?.description) {
        description = product.content.meta.description;
      } else if (typeof product.content === 'string') {
        // Use content as description source
        description = product.content;
      }
    }
    if (!description) {
      description = product.name || '';
    }
    
    // Strip HTML and decode entities, limit to 160 characters for SEO
    description = stripHtmlAndDecode(description);
    if (description.length > 160) {
      description = description.substring(0, 157) + '...';
    }

    // 6. Get keywords from brand and category
    const keywords: string[] = [];
    if (product.brand_name) {
      keywords.push(product.brand_name);
    }
    if (product.category_name) {
      keywords.push(product.category_name);
    }

    // 7. Create/update auto-generated metadata
    const metadata = {
      path,
      title: product.name || '',
      description: description,
      ogImage: thumbnailUrl,
      keywords: keywords,
      enabled: true,
      autoGenerated: true, // Flag to identify auto-generated metadata
    };

    // 8. Update or add product metadata to existing product pages
    const productPagesIndex = existingProductPages.findIndex((p: any) => p.path === path);
    if (productPagesIndex >= 0) {
      existingProductPages[productPagesIndex] = metadata; // Update existing
    } else {
      existingProductPages.push(metadata); // Add new
    }

    // 9. Merge static pages + product pages (preserve all static pages)
    const allPages = [...staticPages, ...existingProductPages];

    // 10. Save to settings - preserve static pages and merge with product pages
    await sequelize.query(
      `INSERT INTO settings (namespace, value, updated_at)
       VALUES (:ns, :val::jsonb, NOW())
       ON CONFLICT (namespace) DO UPDATE SET value = EXCLUDED.value, updated_at = NOW()`,
      {
        type: 'INSERT' as any,
        replacements: {
          ns: 'seo',
          val: JSON.stringify({
            ...seoSettings,
            pages: allPages,
          }),
        },
      }
    );

    console.log(`[syncProductMetadata] Synced metadata for ${path}`);
  } catch (error) {
    console.error('[syncProductMetadata] Error:', error);
    // Don't throw error to avoid breaking product creation/update
  }
}



